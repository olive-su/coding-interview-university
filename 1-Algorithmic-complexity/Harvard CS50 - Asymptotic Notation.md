# **[Harvard CS50 - Asymptotic Notation](https://www.youtube.com/watch?v=iOq5kSKqeR4)**

- 프로그램의 런타임이 점근적으로 얼마나 빨리 증가하는지 분석하는 방법
  - 입력 크기가 무한대로 증가함에 따라 크기가 10인 배열과 비교하여 크기가 100인 배열을 정렬하는 것

<br>

<br>

## **ex1. 문자열의 개수를 세는 방법**

- 문자열의 문자 수 'n'에 대해 선형 시간으로 실행
- 문자 수를 늘리면 런타임은 입력 길이에 따라 선형적으로 증가

$$O(n)$$

<br>

- But, 만약 문자열의 길이를 계산하여 하나의 변수에 저장해놓는 경우 고려
- `len` 이라는 변수에 문자열의 길이를 계산하여 넣어놓는다.

$$O(1)$$

⭐️ **Asymptotic Complexity** ⭐️

- 이는 문자열의 길이에 전혀 상관없이 프로그램 실행 속도에 전혀 영향을 미치지 않는다.
- 1자의 문자열과 1000자의 문자열에서 똑같이 빠르게 실행
- 별도의 메모리 차지 라는 단점 발생
- 단계 수에 관계없이 입력 크기에 따라 변경되지 않으면 여전히 O(1)로 나타내는 점근적으로 일정

<br>

## **다양한 Big-O 알고리즘**

$$O(n^2)$$

- $O(n^2)$ 가 $O(n)$ 에 비해 입력 데이터의 수가 적을 때는 더 빠를 수 있지만 데이터가 많아지면 그 차이가 커진다.

$$O(lgn)$$

- 대표적인 예시 : 이진탐색
- 이미 정렬된 요소에 대한 탐색 수행
- 각 작업에서 배열의 크기를 절반으로 줄인다.
- 배열의 크기를 두배 키우면 해당 코드의 1 Chunk만큼 실행 시간이 늘어난다.
- 목록의 중간 요소를 확인한 다음 분할한다. -> 대수시간 $O(log n)$에서 작동한다.

<br>

- best-case : 처음에 바로 찾고자하는 요소를 찾는 경우
- worst-case : 최후의 경우에 찾고자하는 요소를 찾는 경우

⭐️ **런타임의 상한과 하한** ⭐️
